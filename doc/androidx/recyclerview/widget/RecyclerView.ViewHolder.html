<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_102) on Mon Jun 08 14:16:41 CST 2020 -->
<title>RecyclerView.ViewHolder</title>
<meta name="date" content="2020-06-08">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="RecyclerView.ViewHolder";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":42,"i6":10,"i7":10,"i8":10};
var tabs = {65535:["t0","所有方法"],2:["t2","实例方法"],8:["t4","具体方法"],32:["t6","已过时的方法"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>您的浏览器已禁用 JavaScript。</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="跳过导航链接">跳过导航链接</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="导航">
<li><a href="../../../androidx/recyclerview/widget/package-summary.html">程序包</a></li>
<li class="navBarCell1Rev">类</li>
<li><a href="package-tree.html">树</a></li>
<li><a href="../../../deprecated-list.html">已过时</a></li>
<li><a href="../../../index-all.html">索引</a></li>
<li><a href="../../../help-doc.html">帮助</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../androidx/recyclerview/widget/RecyclerView.ViewCacheExtension.html" title="androidx.recyclerview.widget中的类"><span class="typeNameLink">上一个类</span></a></li>
<li>下一个类</li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?androidx/recyclerview/widget/RecyclerView.ViewHolder.html" target="_top">框架</a></li>
<li><a href="RecyclerView.ViewHolder.html" target="_top">无框架</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">所有类</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>概要:&nbsp;</li>
<li>嵌套&nbsp;|&nbsp;</li>
<li><a href="#field.summary">字段</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">构造器</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">方法</a></li>
</ul>
<ul class="subNavList">
<li>详细资料:&nbsp;</li>
<li><a href="#field.detail">字段</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">构造器</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">方法</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">androidx.recyclerview.widget</div>
<h2 title="类 RecyclerView.ViewHolder" class="title">类 RecyclerView.ViewHolder</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>androidx.recyclerview.widget.RecyclerView.ViewHolder</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>封闭类:</dt>
<dd><a href="../../../androidx/recyclerview/widget/RecyclerView.html" title="androidx.recyclerview.widget中的类">RecyclerView</a></dd>
</dl>
<hr>
<br>
<pre>public abstract static class <span class="typeNameLabel">RecyclerView.ViewHolder</span>
extends java.lang.Object</pre>
<div class="block">A ViewHolder describes an item view and metadata about its place within the RecyclerView.

 <p><a href="../../../androidx/recyclerview/widget/RecyclerView.Adapter.html" title="androidx.recyclerview.widget中的类"><code>RecyclerView.Adapter</code></a> implementations should subclass ViewHolder and add fields for caching
 potentially expensive <code>View#findViewById(int)</code> results.</p>

 <p>While <a href="../../../androidx/recyclerview/widget/RecyclerView.LayoutParams.html" title="androidx.recyclerview.widget中的类"><code>RecyclerView.LayoutParams</code></a> belong to the <a href="../../../androidx/recyclerview/widget/RecyclerView.LayoutManager.html" title="androidx.recyclerview.widget中的类"><code>RecyclerView.LayoutManager</code></a>,
 <a href="../../../androidx/recyclerview/widget/RecyclerView.ViewHolder.html" title="androidx.recyclerview.widget中的类"><code>ViewHolders</code></a> belong to the adapter. Adapters should feel free to use
 their own custom ViewHolder implementations to store data that makes binding view contents
 easier. Implementations should assume that individual item views will hold strong references
 to <code>ViewHolder</code> objects and that <code>RecyclerView</code> instances may hold
 strong references to extra off-screen item views for caching purposes</p></div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!--   -->
</a>
<h3>字段概要</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="字段概要表, 列表字段和解释">
<caption><span>字段</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">限定符和类型</th>
<th class="colLast" scope="col">字段和说明</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>View</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../androidx/recyclerview/widget/RecyclerView.ViewHolder.html#itemView">itemView</a></span></code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>构造器概要</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="构造器概要表, 列表构造器和解释">
<caption><span>构造器</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">构造器和说明</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../androidx/recyclerview/widget/RecyclerView.ViewHolder.html#ViewHolder-View-">ViewHolder</a></span>(View&nbsp;itemView)</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>方法概要</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="方法概要表, 列表方法和解释">
<caption><span id="t0" class="activeTableTab"><span>所有方法</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">实例方法</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">具体方法</a></span><span class="tabEnd">&nbsp;</span></span><span id="t6" class="tableTab"><span><a href="javascript:show(32);">已过时的方法</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">限定符和类型</th>
<th class="colLast" scope="col">方法和说明</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../androidx/recyclerview/widget/RecyclerView.ViewHolder.html#getAdapterPosition--">getAdapterPosition</a></span>()</code>
<div class="block">Returns the Adapter position of the item represented by this ViewHolder.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../androidx/recyclerview/widget/RecyclerView.ViewHolder.html#getItemId--">getItemId</a></span>()</code>
<div class="block">Returns The itemId represented by this ViewHolder.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../androidx/recyclerview/widget/RecyclerView.ViewHolder.html#getItemViewType--">getItemViewType</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../androidx/recyclerview/widget/RecyclerView.ViewHolder.html#getLayoutPosition--">getLayoutPosition</a></span>()</code>
<div class="block">Returns the position of the ViewHolder in terms of the latest layout pass.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../androidx/recyclerview/widget/RecyclerView.ViewHolder.html#getOldPosition--">getOldPosition</a></span>()</code>
<div class="block">When LayoutManager supports animations, RecyclerView tracks 3 positions for ViewHolders
 to perform animations.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../androidx/recyclerview/widget/RecyclerView.ViewHolder.html#getPosition--">getPosition</a></span>()</code>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;
<div class="block"><span class="deprecationComment">This method is deprecated because its meaning is ambiguous due to the async
 handling of adapter updates. You should use <a href="../../../androidx/recyclerview/widget/RecyclerView.ViewHolder.html#getLayoutPosition--"><code>getLayoutPosition()</code></a> or
 <a href="../../../androidx/recyclerview/widget/RecyclerView.ViewHolder.html#getAdapterPosition--"><code>getAdapterPosition()</code></a> depending on your use case.</span></div>
</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../androidx/recyclerview/widget/RecyclerView.ViewHolder.html#isRecyclable--">isRecyclable</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../androidx/recyclerview/widget/RecyclerView.ViewHolder.html#setIsRecyclable-boolean-">setIsRecyclable</a></span>(boolean&nbsp;recyclable)</code>
<div class="block">Informs the recycler whether this item can be recycled.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../androidx/recyclerview/widget/RecyclerView.ViewHolder.html#toString--">toString</a></span>()</code>&nbsp;</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>从类继承的方法&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!--   -->
</a>
<h3>字段详细资料</h3>
<a name="itemView">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>itemView</h4>
<pre>public final&nbsp;View itemView</pre>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>构造器详细资料</h3>
<a name="ViewHolder-View-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>ViewHolder</h4>
<pre>public&nbsp;ViewHolder(View&nbsp;itemView)</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>方法详细资料</h3>
<a name="getPosition--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPosition</h4>
<pre>@Deprecated
public final&nbsp;int&nbsp;getPosition()</pre>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;<span class="deprecationComment">This method is deprecated because its meaning is ambiguous due to the async
 handling of adapter updates. You should use <a href="../../../androidx/recyclerview/widget/RecyclerView.ViewHolder.html#getLayoutPosition--"><code>getLayoutPosition()</code></a> or
 <a href="../../../androidx/recyclerview/widget/RecyclerView.ViewHolder.html#getAdapterPosition--"><code>getAdapterPosition()</code></a> depending on your use case.</span></div>
<dl>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../androidx/recyclerview/widget/RecyclerView.ViewHolder.html#getLayoutPosition--"><code>getLayoutPosition()</code></a>, 
<a href="../../../androidx/recyclerview/widget/RecyclerView.ViewHolder.html#getAdapterPosition--"><code>getAdapterPosition()</code></a></dd>
</dl>
</li>
</ul>
<a name="getLayoutPosition--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLayoutPosition</h4>
<pre>public final&nbsp;int&nbsp;getLayoutPosition()</pre>
<div class="block">Returns the position of the ViewHolder in terms of the latest layout pass.
 <p>
 This position is mostly used by RecyclerView components to be consistent while
 RecyclerView lazily processes adapter updates.
 <p>
 For performance and animation reasons, RecyclerView batches all adapter updates until the
 next layout pass. This may cause mismatches between the Adapter position of the item and
 the position it had in the latest layout calculations.
 <p>
 LayoutManagers should always call this method while doing calculations based on item
 positions. All methods in <a href="../../../androidx/recyclerview/widget/RecyclerView.LayoutManager.html" title="androidx.recyclerview.widget中的类"><code>RecyclerView.LayoutManager</code></a>, <a href="../../../androidx/recyclerview/widget/RecyclerView.State.html" title="androidx.recyclerview.widget中的类"><code>RecyclerView.State</code></a>,
 <a href="../../../androidx/recyclerview/widget/RecyclerView.Recycler.html" title="androidx.recyclerview.widget中的类"><code>RecyclerView.Recycler</code></a> that receive a position expect it to be the layout position
 of the item.
 <p>
 If LayoutManager needs to call an external method that requires the adapter position of
 the item, it can use <a href="../../../androidx/recyclerview/widget/RecyclerView.ViewHolder.html#getAdapterPosition--"><code>getAdapterPosition()</code></a> or
 <a href="../../../androidx/recyclerview/widget/RecyclerView.Recycler.html#convertPreLayoutPositionToPostLayout-int-"><code>RecyclerView.Recycler.convertPreLayoutPositionToPostLayout(int)</code></a>.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>Returns the adapter position of the ViewHolder in the latest layout pass.</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../androidx/recyclerview/widget/RecyclerView.ViewHolder.html#getAdapterPosition--"><code>getAdapterPosition()</code></a></dd>
</dl>
</li>
</ul>
<a name="getAdapterPosition--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAdapterPosition</h4>
<pre>public final&nbsp;int&nbsp;getAdapterPosition()</pre>
<div class="block">Returns the Adapter position of the item represented by this ViewHolder.
 <p>
 Note that this might be different than the <a href="../../../androidx/recyclerview/widget/RecyclerView.ViewHolder.html#getLayoutPosition--"><code>getLayoutPosition()</code></a> if there are
 pending adapter updates but a new layout pass has not happened yet.
 <p>
 RecyclerView does not handle any adapter updates until the next layout traversal. This
 may create temporary inconsistencies between what user sees on the screen and what
 adapter contents have. This inconsistency is not important since it will be less than
 16ms but it might be a problem if you want to use ViewHolder position to access the
 adapter. Sometimes, you may need to get the exact adapter position to do
 some actions in response to user events. In that case, you should use this method which
 will calculate the Adapter position of the ViewHolder.
 <p>
 Note that if you've called <a href="../../../androidx/recyclerview/widget/RecyclerView.Adapter.html#notifyDataSetChanged--"><code>RecyclerView.Adapter.notifyDataSetChanged()</code></a>, until the
 next layout pass, the return value of this method will be <a href="../../../androidx/recyclerview/widget/RecyclerView.html#NO_POSITION"><code>RecyclerView.NO_POSITION</code></a>.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>The adapter position of the item if it still exists in the adapter.
 <code>RecyclerView#NO_POSITION</code> if item has been removed from the adapter,
 <a href="../../../androidx/recyclerview/widget/RecyclerView.Adapter.html#notifyDataSetChanged--"><code>RecyclerView.Adapter.notifyDataSetChanged()</code></a> has been called after the last
 layout pass or the ViewHolder has already been recycled.</dd>
</dl>
</li>
</ul>
<a name="getOldPosition--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOldPosition</h4>
<pre>public final&nbsp;int&nbsp;getOldPosition()</pre>
<div class="block">When LayoutManager supports animations, RecyclerView tracks 3 positions for ViewHolders
 to perform animations.
 <p>
 If a ViewHolder was laid out in the previous onLayout call, old position will keep its
 adapter index in the previous layout.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>The previous adapter index of the Item represented by this ViewHolder or
 <a href="../../../androidx/recyclerview/widget/RecyclerView.html#NO_POSITION"><code>RecyclerView.NO_POSITION</code></a> if old position does not exists or cleared (pre-layout is
 complete).</dd>
</dl>
</li>
</ul>
<a name="getItemId--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getItemId</h4>
<pre>public final&nbsp;long&nbsp;getItemId()</pre>
<div class="block">Returns The itemId represented by this ViewHolder.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>The item's id if adapter has stable ids, <code>RecyclerView#NO_ID</code>
 otherwise</dd>
</dl>
</li>
</ul>
<a name="getItemViewType--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getItemViewType</h4>
<pre>public final&nbsp;int&nbsp;getItemViewType()</pre>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>The view type of this ViewHolder.</dd>
</dl>
</li>
</ul>
<a name="toString--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toString</h4>
<pre>public&nbsp;java.lang.String&nbsp;toString()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>toString</code>&nbsp;在类中&nbsp;<code>java.lang.Object</code></dd>
</dl>
</li>
</ul>
<a name="setIsRecyclable-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setIsRecyclable</h4>
<pre>public final&nbsp;void&nbsp;setIsRecyclable(boolean&nbsp;recyclable)</pre>
<div class="block">Informs the recycler whether this item can be recycled. Views which are not
 recyclable will not be reused for other items until setIsRecyclable() is
 later set to true. Calls to setIsRecyclable() should always be paired (one
 call to setIsRecyclabe(false) should always be matched with a later call to
 setIsRecyclable(true)). Pairs of calls may be nested, as the state is internally
 reference-counted.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>recyclable</code> - Whether this item is available to be recycled. Default value
 is true.</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../androidx/recyclerview/widget/RecyclerView.ViewHolder.html#isRecyclable--"><code>isRecyclable()</code></a></dd>
</dl>
</li>
</ul>
<a name="isRecyclable--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>isRecyclable</h4>
<pre>public final&nbsp;boolean&nbsp;isRecyclable()</pre>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>true if this item is available to be recycled, false otherwise.</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../androidx/recyclerview/widget/RecyclerView.ViewHolder.html#setIsRecyclable-boolean-"><code>setIsRecyclable(boolean)</code></a></dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="跳过导航链接">跳过导航链接</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="导航">
<li><a href="../../../androidx/recyclerview/widget/package-summary.html">程序包</a></li>
<li class="navBarCell1Rev">类</li>
<li><a href="package-tree.html">树</a></li>
<li><a href="../../../deprecated-list.html">已过时</a></li>
<li><a href="../../../index-all.html">索引</a></li>
<li><a href="../../../help-doc.html">帮助</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../androidx/recyclerview/widget/RecyclerView.ViewCacheExtension.html" title="androidx.recyclerview.widget中的类"><span class="typeNameLink">上一个类</span></a></li>
<li>下一个类</li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?androidx/recyclerview/widget/RecyclerView.ViewHolder.html" target="_top">框架</a></li>
<li><a href="RecyclerView.ViewHolder.html" target="_top">无框架</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">所有类</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>概要:&nbsp;</li>
<li>嵌套&nbsp;|&nbsp;</li>
<li><a href="#field.summary">字段</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">构造器</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">方法</a></li>
</ul>
<ul class="subNavList">
<li>详细资料:&nbsp;</li>
<li><a href="#field.detail">字段</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">构造器</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">方法</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
